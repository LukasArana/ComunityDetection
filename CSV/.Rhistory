print("aaa")
print(aaa)
---
output:
pdf_document: default
html_document: default
---
```{r, eval=FALSE}
rm(list=ls())
A <- matrix(c(7, 9, 5, 8, 6, 6, 8, 7, 12, 9), nrow=2, byrow=TRUE)
A
det(A[,c(2,5)])!=0
rm(list=ls())
A <- matrix(c(7, 9, 5, 8, 6, 6, 8, 7, 12, 9), nrow=2, byrow=TRUE)
A
det(A[,c(2,5)])!=0
**`solve(B,b)` funtzioa**. Bideragarriak diren ekuazio linealen sistemak ebazteko `solve` funtzioa erabil daiteke.
```{r, eval=FALSE}
b <- c(54, 72)
solve(A[,c(2,5)], b)
b <- c(54, 72)
solve(A[,c(2,5)], b)
**`combn(x,m)` funtzioa**. Ekuazio linealen sistema bat emanda, oinarriko soluzio guztiak kalkulatzeko, oinarri bat osa dezaketen A matrizeko zutabeen konbinazio guztiak aztertu behar ditugu. `combn(x,m)` funtzioak x bektoreko elementuak m-naka hartuta osatu daitezkeen konbinazio guztiak sortzen ditu, eta konbinazio bakoitzerako zutabe bat duen matrize bat itzultzen du.
```{r, eval=FALSE}
x <- c(1:5)
x
combn(x, 3)
#      [,1] [,2] [,3] [,4] [,5] [,6] [,7] [,8] [,9] [,10]
# [1,]    1    1    1    1    2    2    2    3    3     4
# [2,]    2    3    4    5    3    4    5    4    5     5
combn(x, 2)[,7]
A[,combn(x, 2)[,7]]
solve(A[,combn(x, 2)[,7]], b)
x <- c(1:5)
x
combn(x, 3)
#      [,1] [,2] [,3] [,4] [,5] [,6] [,7] [,8] [,9] [,10]
# [1,]    1    1    1    1    2    2    2    3    3     4
# [2,]    2    3    4    5    3    4    5    4    5     5
combn(x, 2)[,7]
A[,combn(x, 2)[,7]]
solve(A[,combn(x, 2)[,7]], b)
\vspace{1cm}
# Ariketak
**1. ariketa.**  `basic.solution` funtzioa
Idatz ezazu `basic.solution` izeneko funtzio bat, $Ax=b$ ekuazio linealen sistema osatzen duten A matrize bat, $b\geq 0$ bektore bat eta A matrizerako zutabe-indizeen bektore bat emanda, A matrizetik zutabe horiek atera eta oinarri bat osatzen duten egiaztatzeko. Hala bada, funtzioak dagokion $x_B$ oinarriko soluzioa itzuliko du, sistemaren aldagai guztietarako balioak dituen bektore batean. Oinarria ez bada, aldagai guztietarako -1 balioekin osatutako bektorea itzuliko du.
Inplementatu duzun funtzioak emaitza ona ematen duela egiaztatzeko, maximizatze-forma estandarrean idatzitako honako eredu linealarekin egin ditzakezu probak:
rm(list=ls())
A <- matrix(c(2, 1, 1, 8, 1, 1, 2, 1), nrow=2, byrow=TRUE)
b <- c(6, 4)
c <- c(3, 4, 5, 6)
basic.solution <- function( A, b, column.ind.vector){
res <- rep(0, ncol(A))
if (det(A[,column.ind.vector] == 0)){
return( res <- rep(-1, ncol(A)))
}
sol <- solve(A[, column.ind.vector], b)
res[column.ind.vector] <- sol
return(res)
}
basic.solution(A, b, c(1,2))
# [1] 2 2 0 0
basic.solution(A, b, c(1,3))
# [1] 2.6666667 0.0000000 0.6666667 0.0000000
basic.solution(A, b, c(1,4))
# [1]  4.3333333  0.0000000  0.0000000 -0.3333333
basic.solution(A, b, c(2,3))
# [1]  0  8 -2  0
basic.solution(A, b, c(2,4))
# [1] 0.0000000 3.7142857 0.0000000 0.2857143
basic.solution(A, b, c(3,4))
# [1] 0.0000000 0.0000000 1.7333333 0.5333333
all.basic_solutions_for <- function(A, b){
x <- c(1:dim(A)[2])
all.x.b <- list()
all.column.combinations <- combn(x, nrow(A))
for (i in 1:ncol(all.column.combinations)){
print(all.column.combinations[,i])
all.x.b[[i]] <- basic.solution(A, b, all.column.combinations[,i])
}
return(all.x.b)
}
# This function returns a list.
all.basic_solutions_for(A,b)
## [1] 4.3333333  0.0000000  0.0000000 -0.3333333
##
## [[4]]
## [1] 0 8 -2 0
##
## [[5]]
## [1] 0.0000000 3.7142857 0.0000000 0.2857143
##
## [[6]]
## [1] 0.0000000 0.0000000 1.7333333 0.5333333
all.basic_solutions_apply <- function(A,b){
x <- c(1:dim(A)[2])
all.x.b <- list()
all.column.combinations <- combn(x, nrow(A))
res <- apply(all.column.combinations, 2, basic.solution, A= A,b = b )
return(res)
}
# This function returns a matrix. Basic solutions are shown in columns
all.basic_solutions_apply(A,b)
##    [,1]      [,2]       [,3] [,4]      [,5]      [,6]
##[1,]    2 2.6666667  4.3333333    0 0.0000000 0.0000000
##[2,]    2 0.0000000  0.0000000    8 3.7142857 0.0000000
##[3,]    0 0.6666667  0.0000000   -2 0.0000000 1.7333333
##[4,]    0 0.0000000 -0.3333333    0 0.2857143 0.5333333
\vspace{1cm}
basic.feasible.solutions_for <- function(A, b){
x <- c(1:dim(A)[2])
all.x.b <- list()
idx = 1
all.column.combinations <- combn(x, nrow(A))
for (i in 1:ncol(all.column.combinations)){
suitable <- basic.solution(A, b, all.column.combinations[,i])
print(suitable)
if (all(suitable >= 0)){
all.x.b[[idx]] <- suitable
idx <- idx + 1
}
}
return(all.x.b)
}
# This function returns a list.
basic.feasible.solutions_for(A,b)
## [1] 0.0000000 3.7142857 0.0000000 0.2857143
##
## [[4]]
## [1] 0.0000000 0.0000000 1.7333333 0.5333333
#
# Interpretation: There are four basic feasible solutions.
# x1=2, x2=2, x3=0, x4=0
# x1=2.6666667, x2=0.0000000, x3=0.6666667, x4=0.0000000
# x1=0.0000000, x2=3.7142857, x3=0.0000000, x4=0.2857143
# x1=0.0000000, x2=0.0000000, x3=1.7333333, x4=0.5333333
basic.feasible.solutions_apply <- function(A,b){
x <- c(1:dim(A)[2])
all.column.combinations <- combn(x, nrow(A))
res <- apply(all.column.combinations, 2, basic.solution, A= A,b = b)
bektore.logiko <- apply( res, 2, function(param){
return (all(param >=0))
}
)
all.x.b <- res[bektore.logiko]
return(all.x.b)
}
# This function returns a matrix. Basic solutions are shown in columns
basic.feasible.solutions_apply(A,b)
basic.feasible.solutions_apply <- function(A,b){
x <- c(1:dim(A)[2])
all.column.combinations <- combn(x, nrow(A))
res <- apply(all.column.combinations, 2, basic.solution, A= A,b = b)
bektore.logiko <- apply( res, 2, function(param){
return (all(param >=0))
}
)
print(bektore.logiko)
all.x.b <- res[bektore.logiko]
return(all.x.b)
}
# This function returns a matrix. Basic solutions are shown in columns
basic.feasible.solutions_apply(A,b)
basic.feasible.solutions_apply <- function(A,b){
x <- c(1:dim(A)[2])
all.column.combinations <- combn(x, nrow(A))
res <- apply(all.column.combinations, 2, basic.solution, A= A,b = b)
bektore.logiko <- apply( res, 2, function(param){
return (all(param >=0))
}
)
print(bektore.logiko)
print(res)
all.x.b <- res[bektore.logiko]
return(all.x.b)
}
# This function returns a matrix. Basic solutions are shown in columns
basic.feasible.solutions_apply(A,b)
basic.feasible.solutions_apply <- function(A,b){
x <- c(1:dim(A)[2])
all.column.combinations <- combn(x, nrow(A))
res <- apply(all.column.combinations, 2, basic.solution, A= A,b = b)
bektore.logiko <- apply( res, 2, function(param){
return (all(param >=0))
}
)
print(bektore.logiko[0])
print(res)
all.x.b <- res[bektore.logiko]
return(all.x.b)
}
# This function returns a matrix. Basic solutions are shown in columns
basic.feasible.solutions_apply(A,b)
basic.feasible.solutions_apply <- function(A,b){
x <- c(1:dim(A)[2])
all.column.combinations <- combn(x, nrow(A))
res <- apply(all.column.combinations, 2, basic.solution, A= A,b = b)
bektore.logiko <- apply( res, 2, function(param){
return (all(param >=0))
}
)
all.x.b <- res[,bektore.logiko]
return(all.x.b)
}
# This function returns a matrix. Basic solutions are shown in columns
basic.feasible.solutions_apply(A,b)
basic.solution(A, b, c(1,2,3))
basic.solution(A, b, c(1,2,3))
A <- matrix(c(2, 3, -1, 0, 0, 1, 1, 0, 1, 0, -1, 2, 0, 0, 1), nrow=3, byrow=TRUE)
b <- c(1, 3, 5)
A <- matrix(c(2, 3, -1, 0, 0, 1, 1, 0, 1, 0, -1, 2, 0, 0, 1), nrow=3, byrow=TRUE)
b <- c(1, 3, 5)
**1.** Oinarriko soluzioak banaka kalkulatzea, `basic.solution` funtzioa erabiliz.
```{r, eval=FALSE}
basic.solution(A, b, c(1,2,3))
# [1] 0.3333333 2.6666667 7.6666667 0.0000000 0.0000000
basic.solution(A, b, c(1,2,4))
# [1] -1.857143  1.571429  0.000000  3.285714  0.000000
basic.solution(A, b, c(1,2,5))
# [1] 0.3333333 2.6666667 7.6666667 0.0000000 0.0000000
basic.solution(A, b, c(1,2,4))
# [1] -1.857143  1.571429  0.000000  3.285714  0.000000
basic.solution(A, b, c(1,2,5))
# [1]  8 -5  0  0 23
basic.solution(A, b, c(1,3,4))
# [1]  -5   0 -11   8   0
basic.solution(A, b, c(1,3,5))
# [1] 3 0 5 0 8
basic.solution(A, b, c(1,4,5))
# [1] 0.5 0.0 0.0 2.5 5.5
basic.solution(A, b, c(2,3,4))
#  0.0 2.5 6.5 0.5 0.0
basic.solution(A, b, c(2,3,5))
# [1]  0  3  8  0 -1
basic.solution(A, b, c(2,4,5))
# [1] 0.0000000 0.3333333 0.0000000 2.6666667 4.3333333
basic.solution(A, b, c(3,4,5))
# [1]  0  0 -1  3  5
install.packages("RVCompare")
library(RVCompare)
RVCompare
RVCompare*
exit
exit
clear
ls
clear()
exit
exit()
a = 3
print(a)
a = []
a = ()
devtools::install_github("b0rxa/scmamp")
library(tools, lib.loc = "/usr/lib/R/library")
devtools::install_github("b0rxa/scmamp")
devtools::install_github("b0rxa/scmamp")
devtools::install_github("b0rxa/scmamp")
install_github("b0rxa/scmamp")
install.packages("devtools")
install_github("b0rxa/scmamp")
devtools::install_github("b0rxa/scmamp")
library(RVCompare)
library(ggplot2)
library(RVCompare)
library(ggplot2)
setwd ("/home/lufanta/Desktop/2022/BH/proiektua/CSV")
csv_data <- read.csv("REPETIZIOAK")
1
csv_data
X_A <- csv_data$EDA1
X_B <- csv_data$SIMULATED1
if (length(X_A) != length(X_B))
{
stop("length(X_A) != length(X_B)")
}
n <- length(X_A)
# SCATTER
pdf("scatter.pdf")
plot(c(rnorm(length(X_A), mean = 1, sd = 0.2), rnorm(length(X_B), mean = 5, sd = 0.2)),  c(X_A,X_B), xlim = c(0,7), xlab = "X_A                                        X_B")
dev.off()
nbins = 20
dataHist <- data.frame(
value=c(X_A,X_B),
type=c(rep("Name X_A", length(X_A)), rep("Name X_B",  length(X_B)))
)
fig <- ggplot(data=dataHist, aes(x=value, fill=type)) +
geom_histogram(alpha=0.65, position = 'identity', bins = nbins) +
scale_fill_manual(values=c("#1f77b4", "#ff7f0e")) +
ggplot2::xlab('score') +
ggplot2::ylab('count') +
ggplot2::theme_minimal() +
labs(fill="")
ggsave("histogram.pdf", plot=fig,  width = 4, height = 2, device="pdf")
# BOXPLOT
pdf("boxplot.pdf")
boxplot(X_A, X_B, names = c("X_A", "X_B"))
dev.off()
# Measure the number of 'non ties'
n_without_ties <- sum(sign(X_A - X_B) != 0)
# Measure the number of success
n_success <- sum(sign(X_A - X_B) == 1)
binom.test(n_success, n_without_ties, alternative = "two.sided")
is_minimization <- FALSE
cumulative_difference_plot(X_A, X_B,
isMinimizationProblem = is_minimization,
labelA = "EDA", labelB = "SIMULATED", ignoreMinimumLengthCheck = TRUE)
11
X_A
X_B
devtools::install_github("b0rxa/scmamp")
library(scmamp)
library(RVCompare)
library(ggplot2)
setwd ("/home/lufanta/Desktop/2022/BH/proiektua/CSV")
csv_data <- read.csv("REPETIZIOAK")
1
csv_data
cumulative_difference_plot(X_A, X_B,
isMinimizationProblem = is_minimization,
labelA = "EDA", labelB = "SIMULATED", ignoreMinimumLengthCheck = TRUE)
library(scmamp)
library(scmamp)
scmamp::cumulative_difference_plot(X_A, X_B,
isMinimizationProblem = is_minimization,
labelA = "EDA", labelB = "SIMULATED", ignoreMinimumLengthCheck = TRUE)
cumulative_difference_plot(X_A, X_B,
isMinimizationProblem = is_minimization,
labelA = "EDA", labelB = "SIMULATED", ignoreMinimumLengthCheck = TRUE)
cumulative_difference_plot(X_A, X_B,
isMinimizationProblem = is_minimization,
labelA = "EDA", labelB = "SIMULATED", ignoreMinimumLengthCheck = TRUE, labels = c("a", "b"))
cumulative_difference_plot(X_A, X_B,
isMinimizationProblem = is_minimization,
labelA = "EDA", labelB = "SIMULATED", ignoreMinimumLengthCheck = TRUE, labels = c("a", "b"))
cumulative_difference_plot(X_A, X_B,
isMinimizationProblem = is_minimization,
labelA = "EDA", labelB = "SIMULATED", ignoreMinimumLengthCheck = TRUE, labels=c(\"a",\ "b"))
cumulative_difference_plot(X_A, X_B,
isMinimizationProblem = is_minimization,
labelA = "EDA", labelB = "SIMULATED", ignoreMinimumLengthCheck = TRUE)
